package ca.hyperreal.swam

import java.io.Reader

import ca.hyperreal.rtcrdp._


class PrologParser( t: Tokenizer ) extends RecursiveDescentParser( t )
{
	val primaryCallback =
		new ParserCallback
		{
			def apply( token: Int, value: String, argument: Any ) =
			{
				token match
				{
					case PrologParser.INTEGER => NumberAST( value.toInt )
					case PrologParser.FLOAT => NumberAST( value.toDouble )
					case PrologParser.ATOM => AtomAST( Symbol(value) )
					case PrologParser.STRING => StringAST( value )
					case PrologParser.VARIABLE => VariableAST( Symbol(value) )
					case _ => sys.error( "primaryCallback: unknown token: " + token )
				}
			}
		}

	val parenthesesCallback =
		new ParserCallback
		{
			def apply( token: Int, value: String, argument: Any ) = argument
		}

	val listCallback =
		new ParserCallback
		{
			def apply( token: Int, value: String, element: Any ) =
			{
				token match
				{
					case '[' => StructureAST( Symbol("."), Vector(element.asInstanceOf[IndexedSeq[AST]](0), element.asInstanceOf[IndexedSeq[AST]](1)) )
					case ']' => AtomAST( Symbol("[]") )
					case _ => sys.error( "listCallback: unknown token: " + token )
				}
			}
		}

	val operatorCallback =
		new ParserCallback
		{
			def apply( token: Int, value: String, argument: Any ) =
			{
				if (argument == null)
					AtomAST( Symbol(value) )
				else
					if (argument.isInstanceOf[IndexedSeq[Any]])
						StructureAST( Symbol(value), argument.asInstanceOf[IndexedSeq[AST]] )
					else
						AtomAST( Symbol(value) )
			}
		}
}

object PrologParser
{
	val NOT = 0x100
	val AND = NOT+1
	val OR = AND+1
	val MOD = OR+1
	val CLAUSE = MOD+1
	val DIRECTIVE = CLAUSE+1
	val IS = DIRECTIVE+1
	val UNIV = IS+1
	val NE = UNIV+1
	val EE = NE+1
	val NEE = EE+1
	val LE = NEE+1
	val GE = LE+1

	val ATOM = 0x200
	val STRING = 0x201
	val INTEGER = 0x202
	val LONG = 0x203
	val FLOAT = 0x204
	val VARIABLE = 0x205
	
	def tokenizer( r: Reader ) =
		new Tokenizer( r )
		{
			setIdentifier( new AtomLiteral(ATOM) )
			scan( new StringLiteral('"', STRING) )
			scan( new NumericLiteral(INTEGER, FLOAT) )
			scan( new VariableName(VARIABLE) )
			setWhitespace( new Whitespace )
			setOther( ATOM, new Delimiter("()]|'\",_\r\n") )
//			add( new Sym('.', ".") )
			add( new Sym('|', "|") )
		}

	def apply( r: Reader ) =
		new PrologParser( tokenizer(r) )
		{
			add( 1200, CLAUSE, ":-", nonAssociativeBinary, operatorCallback )
			add( 1200, DIRECTIVE, "?-", nonAssociativeUnary, operatorCallback );
			add( 1100, ';', ";", rightAssociative, operatorCallback );
			add( 1000, ',', ",", rightAssociative, operatorCallback )
			add( 900, NOT, "not", associativeUnary, operatorCallback )
			add( 700, '=', "=", nonAssociativeBinary, operatorCallback )
			add( 700, IS, "is", nonAssociativeBinary, operatorCallback );
			add( 700, UNIV, "=..", nonAssociativeBinary, operatorCallback );
			add( 700, NE, "\\=", nonAssociativeBinary, operatorCallback );
			add( 700, EE, "==", nonAssociativeBinary, operatorCallback );
			add( 700, NEE, "\\==", nonAssociativeBinary, operatorCallback );
			add( 700, '<', "<", nonAssociativeBinary, operatorCallback );
			add( 700, '>', ">", nonAssociativeBinary, operatorCallback );
			add( 700, LE, "=<", nonAssociativeBinary, operatorCallback );
			add( 700, GE, ">=", nonAssociativeBinary, operatorCallback );
			add( 500, '+', "+", leftAssociative, operatorCallback )
			add( 500, '-', "-", leftAssociative, operatorCallback )
			add( 400, '*', "*", leftAssociative, operatorCallback )
			add( 400, '/', "/", leftAssociative, operatorCallback )
			add( 300, MOD, "mod", leftAssociative, operatorCallback )
			add( 200, '+', "+", associativeUnary, operatorCallback )
			add( 200, '-', "-", associativeUnary, operatorCallback )
			add( 150, '(', "(", ')', ")", parseCircumfix, parenthesesCallback )	//check precedence
			add( 100, '[', "[", ']', "]", parseList, listCallback )
			add( 150, '{', "{", '}', "}", parseCircumfix, operatorCallback )	//check precedence
			add( 90, ATOM, parseCompound, operatorCallback )
			add( 90, '.', ".", parseCompound, operatorCallback )
			add( 80, INTEGER, parsePrimary, primaryCallback )
			add( 80, LONG, parsePrimary, primaryCallback );
			add( 80, FLOAT, parsePrimary, primaryCallback )
			add( 80, VARIABLE, parsePrimary, primaryCallback )
			add( 80, ATOM, parsePrimary, primaryCallback )
			add( 80, STRING, parsePrimary, primaryCallback )
		}
}